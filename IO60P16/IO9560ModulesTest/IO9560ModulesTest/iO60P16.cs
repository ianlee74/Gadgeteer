using System;
using Microsoft.SPOT;
using Microsoft.SPOT.Hardware;
using GT = Gadgeteer;
using GTM = Gadgeteer.Modules;
using GTI = Gadgeteer.Interfaces;
using Gadgeteer.Interfaces;
using GHIOSH = GHI.OSHW;

namespace Gadgeteer.Modules.Ledonet
{
    public enum PORT_DRIVEMODE
    {
        RES_PULLUP = 0x1D, //Resistive Pull Up Resistive High, Strong Low (default)
        RES_PULLDOWN = 0x1E, //Resistive Pull Down Strong High, Resistive Low
        OPENDRAIN_HIGH = 0x1F, //Open Drain High Slow Strong High, High Z Low
        OPENDRAIN_LOW = 0x20, //Open Drain Low Slow Strong Low, High Z High
        STRONG_DRIVE = 0x21, //Strong Drive Strong High, Strong Low, FastOutput Mode
        SLOW_STRING_DRIVE = 0x22, //Slow Strong Drive Strong High, Strong Low,Slow Output Mode
        HIGH_Z = 0x23  //High Impedance High Z
    }
    /// <summary>
    /// A IO60P16 module for Microsoft .NET Gadgeteer
    /// </summary>
    public class IO60P16 : GTM.Module
    {
        private static GHIOSH.Hardware.SoftwareI2CBus i2c;
        private static GHIOSH.Hardware.SoftwareI2CBus.I2CDevice i2cdevice;
        //private static GTI.SoftwareI2C i2c;
        //private static GTI.I2CBus i2c_hw;

        //
        private Socket _socket;
        public Socket Socket
        {
            get { return _socket; }
            set { _socket = value; }
        }

        //
        InterruptInput interrupt = null;
        /// <summary>
        /// Address of the device.
        /// </summary>
        public const byte DEV_ADDR = 0x20;
        public const byte DEV_ADDR_EEPROM = 0xA0;


        // Interrupt handler delegate
        public delegate void InterruptHandler(object sender, EventArgs args);
        // Interrupt event
        //public event InterruptHandler InterruptEvent;

        // Note: A constructor summary is auto-generated by the doc builder.
        /// <summary></summary>
        /// <param name="socketNumber">The socket that this module is plugged in to.</param>
        public IO60P16(int socketNumber)
        {
            _socket = Socket.GetSocket(socketNumber, true, this, null);
            char[] types = new char[] { 'X', 'Y' };
            _socket.EnsureTypeIsSupported(types, this);

            i2c = new GHIOSH.Hardware.SoftwareI2CBus((Cpu.Pin)_socket.CpuPins[4], (Cpu.Pin)_socket.CpuPins[5]);
            i2cdevice = i2c.CreateI2CDevice(DEV_ADDR, 100);
        }

        public void StartInterruptHandler(InterruptInput.InterruptEventHandler interrupthandler)
        {
            interrupt = new InterruptInput(_socket, GT.Socket.Pin.Three, GlitchFilterMode.Off, ResistorMode.Disabled, InterruptMode.RisingEdge, null);
            interrupt.Interrupt += new InterruptInput.InterruptEventHandler(interrupthandler);
        }

        public void StopInterruptHandler(InterruptInput.InterruptEventHandler interrupthandler)
        {
            if (interrupt != null)
            {
                interrupt.Interrupt -= new InterruptInput.InterruptEventHandler(interrupthandler);
            }
        }
        /// <summary>
        /// Writes a value to a register.
        /// </summary>
        /// <param name="reg">The register to write to.</param>
        /// <param name="value">The value to write.</param>
        public void WriteRegister(byte reg, byte value)
        {
            byte[] data = new byte[] { reg, value };
            int send = i2cdevice.Write(data, 0, data.Length);
        }
        /// <summary>
        /// Reads a value from a register.
        /// </summary>
        /// <param name="reg">The register to read from.</param>
        /// <returns>The value in the register.</returns>
        public byte ReadRegister(byte reg)
        {
            byte[] data = new byte[1];
            // Bring the pointer to the needed address
            int send = i2cdevice.Write(new byte[] { reg }, 0, 1);
            // Read the address
            i2cdevice.Read(data, 0, data.Length);
            return data[0];
        }

        /// <summary>
        /// Writes a value to the specified port.
        /// </summary>
        /// <param name="port">Port to write to.</param>
        /// <param name="value">Value to write to the port.</param>
        private void WritePort(byte port, byte value)
        {
            // Write data start from register 0x08
            WriteRegister((byte)(0x08 + port), value);
            //WriteRegisterHw((byte)(0x08 + port), value);
        }
        
        /// <summary>
        /// Reads the value of a port.
        /// </summary>
        /// <param name="port">The port to read.</param>
        /// <returns>The value of the port.</returns>
        private byte ReadPort(byte port)
        {
            // Read data start from register 0x00
            return ReadRegister((byte)(0x00 + port));
        }

        /// <summary>
        /// Makes a pin an output pin.
        /// </summary>
        /// <param name="port">The port that the pin is in.</param>
        /// <param name="pin">The pin to make an output pin.</param>
        public void MakePinOutput(byte port, byte pin)
        {
            WriteRegister(0x18, port); // Select port
            byte b = ReadRegister(0x1C); // Return value
            b &= (byte)(~(1 << pin)); // 0 is out put
            WriteRegister(0x1C, b);   // write to register

        }

        /// <summary>
        /// Makes a pin an input pin.
        /// </summary>
        /// <param name="port">The port that the pin is in.</param>
        /// <param name="pin">The pin to make an input pin.</param>
        public void MakePinInput(byte port, byte pin)
        {
            WriteRegister(0x18, port); // Select port
            byte b = ReadRegister(0x1C); // Return value
            b |= (byte)((1 << pin)); // 1 is input
            WriteRegister(0x1C, b); // write to register
        }

        /// <summary>
        /// Makes a pin high.
        /// </summary>
        /// <param name="port">The port that the pin is in.</param>
        /// <param name="pin">The pin to make high.</param>
        public void MakePinHigh(byte port, byte pin)
        {
            // Read port
            byte b = ReadPort(port);
            // Config pin
            b |= (byte)(1 << (pin));
            // Apply
            WritePort(port, b);
        }

        /// <summary>
        /// Makes a pin low.
        /// </summary>
        /// <param name="port">The port that the pin is in.</param>
        /// <param name="pin">The pin to make low.</param>
        public void MakePinLow(byte port, byte pin)
        {
            // Read port
            byte b = ReadPort(port);
            // Config pin
            b &= (byte)~(1 << (pin));
            // Config pin
            WritePort(port, b);
        }

        public void SetPortMode(byte port, PORT_DRIVEMODE mode_reg)
        {
            byte hreg = 0x18;
            WriteRegister(hreg, port);
            byte breg = (byte)mode_reg;
            WriteRegister(breg, 0xff);
        }

        // mask = 0bxxxxxxxx where x=1 input pin, x=0 ouput pin
        public void SetPortDirection(byte port, byte mask)
        {
            byte hreg = 0x18, breg = 0x1C;
            WriteRegister(hreg, port);
            WriteRegister(breg, mask);

        }

        public void EnableInterruptPort(byte port, byte mask)
        {
            
            byte hreg = 0x18, breg = 0x19;
            WriteRegister(hreg, port);
            WriteRegister(breg, mask);            
        }

        public void SetPortPWM(byte port, byte mask)
        {
            byte hreg = 0x18, breg = 0x1A;
            WriteRegister(hreg, port);
            WriteRegister(breg, mask);            
        }

        public void SetPortOutput(byte port, byte data)
        {
            WritePort(port, data);
        }

        public byte GetPortInput(byte port)
        {
            byte ret;
            ret = ReadPort(port);
            return ret;
        }
        public byte GetStatusPort(byte port)
        {
            byte ret;
            ret = ReadRegister((byte)(0x10 + port));
            return ret;
        }
    }
}